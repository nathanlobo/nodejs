<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Interactive C++ Terminal</title>
  <style>
    :root {
    --bg: #0d1117;
    --panel: #0d1117;
    --muted: #8b949e;
    --border: #30363d;
    --accent: #74b5ff;
    --text: #c9d1d9;
    --warning:yellow;
  }
  :root.light {
    --bg: #ffffff;
    --panel: #f6f8fa;
    --muted: #57606a;
    --border: #d0d7de;
    --accent: #0969da;
    --text: #24292f;
    --warning:#ffcc00;
  }
    * {
  box-sizing: border-box;
}

html, body {
  height: 100%;
  margin: 0;
  padding: 0;
}

body {
  font-family: system-ui, -apple-system, 'Segoe UI', Roboto, Arial;
  padding: 12px;
  background: #1e1e1e;
  color: #e8e8e8;
  max-width: 1000px;
  margin: 0 auto;
}

button {
  font-size: 18px;
  font-weight: 600;
  padding: 16px 28px;
  background: #0e639c;
  color: #fff;
  border: none;
  border-radius: 12px;
  cursor: pointer;
  margin: 8px 6px 8px 0;
  min-width: 160px;
  box-shadow: 0 6px 20px rgba(0,0,0,0.25);
  transition: all 150ms;
}

button:hover {
  background: #1177bb;
  box-shadow: 0 8px 24px rgba(0,0,0,0.3);
}

button:disabled {
  background: #444;
  color: #888;
  cursor: not-allowed;
  opacity: 0.6;
}

#screenshotBtn {
  background: #1a7fbf;
}

#screenshotBtn:hover {
  background: #1a8fcf;
}

#runButton {
  background: #2563eb;
  font-weight: 700;
}

#runButton:hover {
  background: #1d4ed8;
}

#runButton:disabled {
  background: #444;
}

#stopButton {
  background: #dc2626;
  font-weight: 700;
}

#stopButton:hover {
  background: #b91c1c;
}

/* CSS for Pop up to ask for name */
  .modal {
    display: block; /* Hidden by default */
    position: fixed; /* Stay in place, even on scroll */
    z-index: 1000; /* Sit on top of everything */
    left: 0;
    top: 0;
    width: 100%;
    height: 100%;
    background-color: rgba(0, 0, 0, 0.5); /* Black with 50% opacity */
  }

  /* The modal's content box */
  .modal-content {
    background-color: var(--bg);
    /* Center the modal */
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    
    /* More comfortable padding and box sizing */
    padding: 16px 18px;
    border: 1px solid var(--text);
    width: 88%;
    max-width: 450px;
    border-radius: 10px;
    box-shadow: 0 5px 15px rgba(0,0,0,0.3);
    text-align: center;
  }
  .modal-content p {
    line-height: 1.2;
    font-size: 17px;
    margin: 0 0 8px 0;
  }
  .modal-content i {
    font-size: 15px;
    color: var(--warning);
    display: block;
    margin-bottom: 10px;
    letter-spacing: 0.5px;
  }
  /* Form layout inside modal: center inputs and make them responsive */
  #nameForm {
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 10px;
    width: 100%;
    box-sizing: border-box;
  }
  .btnGrp {
    display: flex;
    justify-content: flex-end; /* align buttons to the right */
    align-items: center;
    gap: 12px;
    width: 100%;
    box-sizing: border-box;
    margin-top: 6px;
  }

  /* Style the form elements */
  #nameForm input[type="text"] {
    width: 100%;
    box-sizing: border-box;
    padding: 12px;
    margin: 0;
    border: 1px solid var(--border);
    border-radius: 5px;
    font-size: 16px;
  }

  #nameForm button, input[type="button"] {
    margin-bottom: 5px;
    background-color: var(--accent);
    color: white;
    padding: 12px 25px;
    border: none;
    border-radius: 5px;
    cursor: pointer;
    font-size: 16px;
    transition: background-color 0.3s;
  }

  #nameForm button:hover,input[type="button"]:hover {
    background-color: #0056b3;
  }
  
  @media (max-width: 620px){
    #nameForm button:hover,input[type="button"]:hover {
      background-color: #0056b3;
    }
  }
  /********* Pop up CSS Ends Here *********/

#console {
  width: 100%;
  font-family: Consolas, Monaco, monospace;
  font-size: 15px;
  background: #0c0c0c;
  color: #f0f0f0;
  border: 2px solid #333;
  border-radius: 10px;
  padding: 16px;
  resize: vertical;
  min-height: 400px;
  white-space: pre-wrap;
}

#console:focus {
  outline: none;
  border-color: #0e639c;
}

.info {
  color: #a0a0a0;
  font-size: 16px;
  font-weight: 600;
  margin-bottom: 12px;
}

.not-found {
  color: #ff6b6b;
  font-size: 20px;
  font-weight: 800;
  text-align: center;
  padding: 18px;
  border: 1px solid rgba(255,107,107,0.15);
  background: rgba(255,107,107,0.03);
  border-radius: 8px;
  margin: 12px 0;
}

.top-row {
  display: flex;
  gap: 8px;
  align-items: center;
  flex-wrap: wrap;
}

/* Mobile adjustments */
@media (max-width:640px){
  body{
    padding:8px
  }
  .top-row{
    flex-direction:column;
    align-items:stretch}
  button{
    font-size:16px;
    padding:12px 16px;
    min-width:unset;
    width:100%;
    margin:6px 0}
  #console{
    height:60vh;
    min-height:500px;
    padding:10px;
    font-size:30px}
  .info{
    font-size:14px
  }
}
  </style>
</head>
<body>
  <div id="selectedInfo" class="info"><span id="selectedId">-</span> - <span id="selectedPath">(unknown)</span></div>
  <div class="top-row">
    <button id="runButton">â–¶ Run C++ Code</button>
    <button id="stopButton" style="display:none;">â–  Stop</button>
    <button id="screenshotBtn" style="display:none;">ðŸ“¸ Screenshot</button>
  </div>
  <div id="analyticsModal" class="modal">
    <div class="modal-content">
      <p id="modal-text">Need your Name or Roll No. to be displayed in the code</p>
      <i id="modal-warning">Note: The above mention feature is in development & not yet published</i>
      <form id="nameForm">
        <input type="text" id="userName" name="userName" placeholder="Enter your Name or Roll No" required>
        <div class="btnGrp">
          <input type="button" id="skip" value="Skip">
          <button type="submit">Submit</button>
        </div>
      </form>
    </div>
  </div>
  <textarea id="console" rows="20" spellcheck="false">Click "Run C++ Code" to start...</textarea>
  <script src="/socket.io/socket.io.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
  <script>
    skipBtn = document.getElementById("skip");
    skipCount = 0;
    skipBtn.addEventListener("click", function() {
      if (skipCount==0){
        const modalText = document.getElementById("modal-text");
        const modalWarn = document.getElementById("modal-warning");
        modalText.textContent = "I've Asked Just for your name, Not your Bank Account details.";
        modalWarn.textContent = "";
        skipCount += 1;
      }
      else if (skipCount==1){
        const modalText = document.getElementById("modal-text");
        modalText.textContent = "Are you sure? You won't get any future features";
        skipCount++;
      }
      else if (skipCount==2){
        const modal = document.getElementById("analyticsModal");
        modal.style.display = "none";
      }
    });
    const GOOGLE_SCRIPT_URL = 'https://script.google.com/macros/s/AKfycbwgXbi_LPG8TjWaOjeT2cPUWeoBRJ3U0DSrJTy3ikAn0hdXJ7nSXedTx_mu3xbHQLLm/exec';
    window.onload = function() {
      const storedName = localStorage.getItem('userName');
      const currentTab = localStorage.getItem('selectedTab') || 'HTML';
      
      if (storedName) {
        console.log("Welcome back, " + storedName + "! Logging your visit.");
        const visitType = 'Return Visit';
        // Send immediately for returning visitors
        sendAnalyticsData(storedName, visitType, currentTab);
      } else {
        console.log("First visit. Showing modal.");
        const modal = document.getElementById("analyticsModal");
        const form = document.getElementById("nameForm");
        modal.style.display = "none"; ////////// Change to "block" to enable popup ////////////
        document.getElementById("userName").focus();
        form.addEventListener("submit", function(event) {
          event.preventDefault();
          const userName = document.getElementById("userName").value.trim();
          if (userName) {
            localStorage.setItem('userName', userName);
            modal.style.display = "none";
            // Send right after the user submits their name on first visit
            sendAnalyticsData(userName, 'First Visit', localStorage.getItem('selectedTab') || 'HTML');
          }
        });
      }
    };

    function sendAnalyticsData(name, visitType, visitPage) {
        const url = `${GOOGLE_SCRIPT_URL}?userName=${encodeURIComponent(name)}&visitType=${encodeURIComponent(visitType)}&visitPage=${encodeURIComponent(visitPage)}`;
        fetch(url, { method: 'POST', mode: 'no-cors' })
        .then(() => { console.log(`Analytics data sent: ${name} - ${visitType}`); })
        .catch(error => { console.error('Error sending analytics data:', error); });
    }
    const runButton = document.getElementById('runButton');
    const stopButton = document.getElementById('stopButton');
    const consoleEl = document.getElementById('console');

    // Establish Socket.IO connection - always connect to same origin (works for localhost, tunnels, and Render)
    let socket;
    (function ensureIoAndConnect() {
      function connect() {
        try {
          // Always connect to the same origin as the page (works for all deployment scenarios)
          // This handles localhost, dev tunnels, and production deploys automatically
          socket = io();
          attachSocketHandlers();
          console.log('Socket.IO connected to:', window.location.origin);
        } catch (e) {
          console.error('Socket.IO connect failed', e);
        }
      }
      if (typeof io !== 'undefined') {
        connect();
      } else {
        // Load client from CDN if not available (fallback for Live Preview scenarios)
        const s = document.createElement('script');
        s.src = 'https://cdn.socket.io/4.7.2/socket.io.min.js';
        s.crossOrigin = 'anonymous';
        s.onload = connect;
        s.onerror = () => console.error('Failed to load Socket.IO client');
        document.head.appendChild(s);
      }
    })();

    let isRunning = false;
    // All text before lockIndex is read-only output. User types only after lockIndex.
    let lockIndex = 0;

    function setConsole(text) {
      consoleEl.value = text;
      scrollToBottom();
    }

    function appendToConsole(text) {
      const atEnd = isCaretAtEnd();
      consoleEl.value += text;
      // Advance lock to the new end for output
      lockIndex = consoleEl.value.length;
      if (atEnd) moveCaretToEnd();
      scrollToBottom();
    }

    function scrollToBottom() {
      consoleEl.scrollTop = consoleEl.scrollHeight;
    }

    function moveCaretToEnd() {
      consoleEl.selectionStart = consoleEl.selectionEnd = consoleEl.value.length;
    }

    function isCaretAtEnd() {
      return consoleEl.selectionStart === consoleEl.value.length && consoleEl.selectionEnd === consoleEl.value.length;
    }

    function getUserInput() {
      return consoleEl.value.slice(lockIndex);
    }

    function setUserInput(text) {
      consoleEl.value = consoleEl.value.slice(0, lockIndex) + text;
      moveCaretToEnd();
    }

    function getIdFromQuery() {
      try {
        const params = new URLSearchParams(window.location.search);
        const idParam = params.get('id');
        if (idParam) return idParam;
        
        // Check for other query params, but ignore 'rollNo'
        for (const key of params.keys()) {
          if (key && key !== 'rollNo') return key;
        }
        
        // Check path for ID (first segment only)
        const path = window.location.pathname || '/';
        if (path && path.length > 1) {
          const segments = path.replace(/^\/+|\/+$/g, '').split('/');
          if (segments.length >= 1 && segments[0]) {
            return segments[0]; // Return first segment as ID
          }
        }
        return null;
      } catch (e) {
        return null;
      }
    }

    function getRollNoFromQuery() {
      try {
        const params = new URLSearchParams(window.location.search);
        const rollNoParam = params.get('rollNo');
        if (rollNoParam) return rollNoParam.toLowerCase();
        
        // Check path for pattern like /1a/25lec07
        const path = window.location.pathname || '/';
        if (path && path.length > 1) {
          const segments = path.replace(/^\/+|\/+$/g, '').split('/');
          if (segments.length === 2) {
            return segments[1].toLowerCase();
          }
        }
        return null;
      } catch (e) {
        return null;
      }
    }

    runButton.addEventListener('click', () => {
      if (isRunning) return;
      isRunning = true;
      runButton.disabled = true;
      runButton.textContent = 'â³ Running...';
      setConsole('Setting up code.\n');
      lockIndex = 0;
      consoleEl.focus();
      if (!socket || typeof socket.emit !== 'function') {
        appendToConsole('Connecting to server... Please try Run again in a moment.\n');
        isRunning = false;
        runButton.disabled = false;
        runButton.textContent = 'â–¶ Run C++ Code';
        return;
      }
      const id = getIdFromQuery();
      const rollNo = getRollNoFromQuery();
      const payload = { id: id || undefined, rollNo: rollNo || undefined };
      socket.emit('run-interactive', payload);
      
      // Track analytics for Run button (fallback to rollNo or Anonymous)
      const storedName = localStorage.getItem('userName');
      const rollNoForAnalytics = getRollNoFromQuery();
      const nameForAnalytics = storedName || (rollNoForAnalytics ? rollNoForAnalytics.toUpperCase() : 'Anonymous');
      sendAnalyticsData(nameForAnalytics, 'Run', window.location.href);
    });

    stopButton.addEventListener('click', () => {
      if (confirm('Are you sure you want to stop the execution?')) {
        if (socket && typeof socket.emit === 'function') {
          socket.emit('stop');
        }
        isRunning = false;
        runButton.disabled = false;
        runButton.textContent = 'â–¶ Run C++ Code';
        stopButton.style.display = 'none';
        // Keep screenshot button visible after stopping
        runButton.style.display = 'inline-block';
        appendToConsole('\n[Execution stopped by user]\n');
        
        // Track analytics for Stop button (fallback to rollNo or Anonymous)
        const storedName = localStorage.getItem('userName');
        const rollNoForAnalytics = getRollNoFromQuery();
        const nameForAnalytics = storedName || (rollNoForAnalytics ? rollNoForAnalytics.toUpperCase() : 'Anonymous');
        sendAnalyticsData(nameForAnalytics, 'Stop', window.location.href);
    }});

    const selectedIdEl = document.getElementById('selectedId');
    const selectedPathEl = document.getElementById('selectedPath');
    function showMappingForId(id) {
      if (!id) {
        selectedIdEl.textContent = '-';
        selectedPathEl.textContent = '(unknown)';
        return Promise.resolve(null);
      }
      selectedIdEl.textContent = id;
      return fetch(`/mapping?id=${encodeURIComponent(id)}`)
        .then(r => r.json())
        .then(j => {
          if (j && j.path) {
            selectedPathEl.textContent = j.path;
            localStorage.setItem('filePath', j.path);
          } else {
            selectedPathEl.textContent = '(local filename)';
          }
          return j;
        })
        .catch(() => { selectedPathEl.textContent = '(error)'; return null; });
    }

    const initialId = getIdFromQuery();
    let autoRun = false;
    showMappingForId(initialId).then((j) => {
      if (j && j.path && initialId) {
        autoRun = true;
        setTimeout(() => runButton.click(), 250);
      }
    });
    window.addEventListener('popstate', () => showMappingForId(getIdFromQuery()));

    function attachSocketHandlers() {
      if (!socket || typeof socket.on !== 'function') return;
      socket.on('output', (data) => {
        appendToConsole(data);
        if (data.includes('Compilation successful')) {
          setTimeout(() => {
            setConsole('');
            lockIndex = 0;
          }, 800);
          runButton.style.display = 'none';
          screenshotBtn.style.display = 'inline-block';
          stopButton.style.display = 'inline-block';
        }
      });

      socket.on('done', () => {
        isRunning = false;
        runButton.disabled = false;
        runButton.textContent = 'â–¶ Run C++ Code';
        stopButton.style.display = 'none';
        // Keep screenshot button visible after code execution
        runButton.style.display = 'inline-block';
        appendToConsole('\n');
        if (autoRun) {
          const txt = consoleEl.value || '';
          const compileFail = txt.includes('Compilation failed');
          const procError = txt.includes('Process error') || txt.includes('[Process was killed') || /\[Process exited with code (\d+)\]/.test(txt) && !/\[Process exited with code 0\]/.test(txt);
          if (compileFail || procError) {
            appendToConsole('\nAn error occured: Refresh or press Run C++ code.\n');
          }
          autoRun = false;
        }
      });
    }

    (function setupScreenshot(){
      const screenshotBtn = document.getElementById('screenshotBtn');
      screenshotBtn.addEventListener('click', async () => {
        try {
          screenshotBtn.textContent = 'â³ Generating...';
          screenshotBtn.disabled = true;
          const text = consoleEl.value || '';
          const cs = window.getComputedStyle(consoleEl);
          const temp = document.createElement('div');
          temp.style.whiteSpace = 'pre-wrap';
          temp.style.fontFamily = cs.fontFamily;
          temp.style.fontSize = cs.fontSize;
          temp.style.lineHeight = cs.lineHeight;
          temp.style.color = cs.color;
          temp.style.background = cs.backgroundColor || '#0c0c0c';
          temp.style.padding = cs.padding;
          temp.style.borderRadius = cs.borderRadius || '6px';
          temp.style.boxSizing = 'border-box';
          temp.style.width = (consoleEl.clientWidth) + 'px';
          temp.style.maxWidth = temp.style.width;
          temp.style.position = 'fixed';
          temp.style.left = '-99999px';
          temp.style.top = '0';
          temp.textContent = text;
          document.body.appendChild(temp);
          const canvas = await html2canvas(temp, { backgroundColor: null, useCORS: true, scale: 2 });
          temp.remove();

          canvas.toBlob((blob) => {
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'console-screenshot.png';
            document.body.appendChild(a);
            a.click();
            a.remove();
            URL.revokeObjectURL(url);
            screenshotBtn.textContent = 'âœ… Downloaded';
            setTimeout(() => { screenshotBtn.textContent = 'ðŸ“¸ Screenshot'; screenshotBtn.disabled = false; }, 2000);
          });

          // Track analytics for Screenshot (fallback to rollNo or Anonymous)
          const storedName = localStorage.getItem('userName');
          const rollNoForAnalytics = getRollNoFromQuery();
          const nameForAnalytics = storedName || (rollNoForAnalytics ? rollNoForAnalytics.toUpperCase() : 'Anonymous');
          sendAnalyticsData(nameForAnalytics, 'Screenshot', window.location.href);
        } catch (e) {
          console.error('Screenshot failed', e);
          screenshotBtn.textContent = 'âŒ Failed';
          setTimeout(() => { screenshotBtn.textContent = 'ðŸ“¸ Screenshot'; screenshotBtn.disabled = false; }, 2000);
        }
      });
    })();

    consoleEl.addEventListener('keydown', (e) => {
      if (!isRunning) return;
      const start = consoleEl.selectionStart;
      const end = consoleEl.selectionEnd;
      if (e.key === 'Home' || e.key === 'PageUp') {
        e.preventDefault();
        consoleEl.selectionStart = consoleEl.selectionEnd = lockIndex;
        return;
      }
      if ((e.key === 'ArrowLeft' || e.key === 'ArrowUp') && start <= lockIndex) {
        e.preventDefault();
        consoleEl.selectionStart = consoleEl.selectionEnd = lockIndex;
        return;
      }
      if (e.key === 'Backspace' && (start <= lockIndex)) {
        e.preventDefault();
        return;
      }
      if (e.key === 'Delete' && start < lockIndex) {
        e.preventDefault();
        return;
      }
      if (e.key === 'Enter') {
        e.preventDefault();
        const input = getUserInput();
        socket.emit('input', input);
        appendToConsole('\n');
        lockIndex = consoleEl.value.length;
      }
    });

    consoleEl.addEventListener('paste', (e) => {
      if (!isRunning) return;
      const start = consoleEl.selectionStart;
      if (start < lockIndex) {
        e.preventDefault();
        const text = (e.clipboardData || window.clipboardData).getData('text');
        setUserInput(getUserInput() + text);
      }
    });

    consoleEl.addEventListener('click', () => {
      if (!isRunning) return;
      if (consoleEl.selectionStart < lockIndex) {
        consoleEl.selectionStart = consoleEl.selectionEnd = consoleEl.value.length;
      }
    });
  </script>
</body>
</html>