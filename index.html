<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Interactive C++ Terminal</title>
  <style>
    /* Base layout and responsive sizing */
    :root {
      --bg: #1e1e1e;
      --panel: #0c0c0c;
      --text: #e8e8e8;
      --muted: #a0a0a0;
      --accent: #0e639c;
      --button-padding: 10px 20px;
      --radius: 8px;
    }

    * {
      box-sizing: border-box;
      -webkit-tap-highlight-color: transparent;
    }

    html,body{height:100%; margin: 0; padding: 0;}
    body {
      font-family: system-ui, -apple-system, 'Segoe UI', Roboto, 'Helvetica Neue', Arial;
      padding: 12px;
      background: var(--bg);
      color: var(--text);
      max-width: 1000px;
      margin: 0 auto;
      -webkit-font-smoothing:antialiased;
      -moz-osx-font-smoothing: grayscale;
    }

    /* Buttons (mobile-friendly) - enlarged */
    button {
      font-size: 18px;
      font-weight: 600;
      padding: 16px 28px;
      background: var(--accent);
      color: #ffffff;
      border: none;
      border-radius: 12px;
      cursor: pointer;
      margin: 8px 6px 8px 0;
      min-height: 54px;
      min-width: 160px;
      box-shadow: 0 6px 20px rgba(0,0,0,0.25);
      transition: all 150ms ease;
      touch-action: manipulation;
      user-select: none;
    }
    button:hover { background: #1177bb; transform: translateY(-1px); box-shadow: 0 8px 24px rgba(0,0,0,0.3); }
    button:active { transform: translateY(0); box-shadow: 0 4px 12px rgba(0,0,0,0.2); }
    button:disabled { background: #444; color: #888; cursor: not-allowed; box-shadow: none; opacity: 0.6; }

    /* Specific visual tweak for the screenshot button which is injected dynamically */
    #screenshotBtn {
      font-size: 18px;
      padding: 16px 24px;
      min-width: 160px;
      margin-left: 8px;
      display: inline-block;
      background: #1a7fbf;
    }
    #screenshotBtn:hover { background: #1a8fcf; }

    /* Make the Run button visually distinct and prominent */
    #runButton {
      background: #2563eb;
      color: #ffffff;
      font-weight: 700;
      padding: 16px 32px;
      box-shadow: 0 6px 24px rgba(37,99,235,0.3);
    }
    #runButton:hover { background: #1d4ed8; box-shadow: 0 8px 28px rgba(37,99,235,0.4); }
    #runButton:disabled { background: #444; box-shadow: none; }

    /* Console textarea styles */
    #console {
      width: 100%;
      font-family: 'Consolas', 'Monaco', 'Courier New', monospace;
      font-size: 15px;
      background: var(--panel);
      color: #f0f0f0;
      border: 2px solid #333;
      border-radius: 10px;
      padding: 16px;
      line-height: 1.6;
      resize: vertical;
      min-height: 400px;
      max-height: 75vh;
      height: auto;
      white-space: pre-wrap;
      overflow: auto;
      word-break: break-word;
      -webkit-overflow-scrolling: touch;
    }
    #console:focus {
      outline: none;
      border-color: #0e639c;
      box-shadow: 0 0 0 3px rgba(14,99,156,0.15);
    }

    .info {
      color: var(--muted);
      font-size: 16px;
      font-weight: 600;
      margin-bottom: 12px;
      word-break: break-word;
      line-height: 1.4;
    }

    /* Not-found message styling if shown in-page */
    .not-found {
      display: block;
      color: #ff6b6b;
      font-size: 20px;
      font-weight: 800;
      text-align: center;
      padding: 18px;
      border: 1px solid rgba(255,107,107,0.15);
      background: rgba(255,107,107,0.03);
      border-radius: 8px;
      margin: 12px 0;
    }

    /* Layout helpers */
    .top-row { display:flex; gap:8px; align-items:center; flex-wrap:wrap; }

    /* Responsive adjustments for mobile phones */
    @media (max-width: 640px) {
      body { 
        padding: 8px;
        font-size: 16px;
      }
      
      .info { 
        font-size: 15px;
        margin-bottom: 10px;
        line-height: 1.5;
      }
      
      /* Make control buttons full-width and larger for touch */
      button { 
        width: 100%;
        font-size: 17px;
        font-weight: 700;
        padding: 18px 16px;
        margin: 6px 0;
        min-width: auto;
        min-height: 58px;
        border-radius: 10px;
      }
      
      #screenshotBtn { 
        margin-left: 0 !important;
        margin-top: 6px;
        display: block;
        width: 100%;
      }
      
      #runButton { 
        min-height: 62px;
        font-size: 18px;
        margin-bottom: 8px;
      }
      
      /* Make console take the majority of the viewport height on phones */
      #console {
        font-size: 15px;
        min-height: 55vh;
        max-height: 70vh;
        line-height: 1.7;
        padding: 14px;
        border-radius: 8px;
        border-width: 2px;
      }
    }

    /* Tablet adjustments */
    @media (min-width: 641px) and (max-width: 900px) {
      body { padding: 12px; }
      .info { font-size: 16px; }
      #console { 
        min-height: 380px;
        font-size: 15px;
      }
      button { 
        padding: 14px 20px;
        font-size: 17px;
      }
    }

    /* Very small phones */
    @media (max-width: 380px) {
      body { padding: 6px; }
      .info { font-size: 14px; }
      button { 
        font-size: 16px;
        padding: 16px 12px;
        min-height: 56px;
      }
      #console {
        font-size: 14px;
        padding: 12px;
        min-height: 50vh;
      }
    }
  </style>
</head>
<body>
  <div id="selectedInfo" class="info"><span id="selectedId">-</span> - <span id="selectedPath">(unknown)</span></div>
  <button id="runButton">â–¶ Run C++ Code</button>
  <textarea id="console" rows="20" spellcheck="false">Click "Run C++ Code" to start...</textarea>

  <script src="/socket.io/socket.io.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
  <script>
    const runButton = document.getElementById('runButton');
    const consoleEl = document.getElementById('console');

    // Establish Socket.IO connection - always connect to same origin (works for localhost, tunnels, and Render)
    let socket;
    (function ensureIoAndConnect() {
      function connect() {
        try {
          // Always connect to the same origin as the page (works for all deployment scenarios)
          // This handles localhost, dev tunnels, and production deploys automatically
          socket = io();
          attachSocketHandlers();
          console.log('Socket.IO connected to:', window.location.origin);
        } catch (e) {
          console.error('Socket.IO connect failed', e);
        }
      }
      if (typeof io !== 'undefined') {
        connect();
      } else {
        // Load client from CDN if not available (fallback for Live Preview scenarios)
        const s = document.createElement('script');
        s.src = 'https://cdn.socket.io/4.7.2/socket.io.min.js';
        s.crossOrigin = 'anonymous';
        s.onload = connect;
        s.onerror = () => console.error('Failed to load Socket.IO client');
        document.head.appendChild(s);
      }
    })();

    let isRunning = false;
    // All text before lockIndex is read-only output. User types only after lockIndex.
    let lockIndex = 0;

    function setConsole(text) {
      consoleEl.value = text;
      scrollToBottom();
    }

    function appendToConsole(text) {
      const atEnd = isCaretAtEnd();
      consoleEl.value += text;
      // Advance lock to the new end for output
      lockIndex = consoleEl.value.length;
      if (atEnd) moveCaretToEnd();
      scrollToBottom();
    }

    function scrollToBottom() {
      consoleEl.scrollTop = consoleEl.scrollHeight;
    }

    function moveCaretToEnd() {
      consoleEl.selectionStart = consoleEl.selectionEnd = consoleEl.value.length;
    }

    function isCaretAtEnd() {
      return consoleEl.selectionStart === consoleEl.value.length && consoleEl.selectionEnd === consoleEl.value.length;
    }

    function getUserInput() {
      return consoleEl.value.slice(lockIndex);
    }

    function setUserInput(text) {
      consoleEl.value = consoleEl.value.slice(0, lockIndex) + text;
      moveCaretToEnd();
    }

    // Helper to get `id` from URL query string (e.g. ?id=2)
    function getIdFromQuery() {
      try {
        // Prefer explicit ?id=... query param
        const params = new URLSearchParams(window.location.search);
        const idParam = params.get('id');
        if (idParam) return idParam;
        // Support shorthand query like `/?1a` (no `id=` key): use first key if present
        for (const key of params.keys()) {
          if (key) return key;
        }
        // If no query param, support path-style URL like /1a by reading pathname
        const path = window.location.pathname || '/';
        if (path && path.length > 1) {
          // strip leading slash and any trailing slashes
          const trimmed = path.replace(/^\/+|\/+$/g, '');
          // only accept short single-segment ids (no slashes left)
          if (!trimmed.includes('/')) return trimmed;
        }
        return null;
      } catch (e) {
        return null;
      }
    }

    runButton.addEventListener('click', () => {
      if (isRunning) return;

      isRunning = true;
      runButton.disabled = true;
      runButton.textContent = 'â³ Running...';
      setConsole('');
      lockIndex = 0;
      consoleEl.focus();

      // Guard: if socket isn't ready yet (e.g., CDN still loading), show a message.
      if (!socket || typeof socket.emit !== 'function') {
        appendToConsole('Connecting to server... Please try Run again in a moment.\n');
        isRunning = false;
        runButton.disabled = false;
        runButton.textContent = 'â–¶ Run C++ Code';
        return;
      }

      // Send the id (if present in the URL) so the server can pick the file.
      const id = getIdFromQuery();
      if (id) socket.emit('run-interactive', { id });
      else socket.emit('run-interactive');
    });

    // Display mapping info in the UI
    const selectedIdEl = document.getElementById('selectedId');
    const selectedPathEl = document.getElementById('selectedPath');
    function showMappingForId(id) {
      if (!id) {
        selectedIdEl.textContent = '-';
        selectedPathEl.textContent = '(unknown)';
        return Promise.resolve(null);
      }
      selectedIdEl.textContent = id;
      return fetch(`/mapping?id=${encodeURIComponent(id)}`)
        .then(r => r.json())
        .then(j => {
          if (j && j.path) {
            selectedPathEl.textContent = j.path;
            // store filePath for analytics
            localStorage.setItem('filePath', j.path);
          } else {
            selectedPathEl.textContent = '(local filename)';
          }
          return j;
        })
        .catch(() => { selectedPathEl.textContent = '(error)'; return null; });
    }

    // Show mapping at load and whenever the URL changes (back/forward)
    const initialId = getIdFromQuery();
    // Auto-start run flag
    let autoRun = false;
    // showMappingForId returns a promise; when mapping is available, auto-run
    showMappingForId(initialId).then((j) => {
      if (j && j.path && initialId) {
        // small delay to allow socket to connect
        autoRun = true;
        setTimeout(() => runButton.click(), 250);
      }
    });
    window.addEventListener('popstate', () => showMappingForId(getIdFromQuery()));

    // Attach socket event handlers after the socket connects/exists
    function attachSocketHandlers() {
      if (!socket || typeof socket.on !== 'function') return;
      socket.on('output', (data) => {
        appendToConsole(data);
      });

      socket.on('done', () => {
        isRunning = false;
        runButton.disabled = false;
        runButton.textContent = 'â–¶ Run C++ Code';
        appendToConsole('\n');
        // If this was an auto-run and the output indicates failure, show friendly message
        if (autoRun) {
          const txt = consoleEl.value || '';
          const compileFail = txt.includes('Compilation failed');
          const procError = txt.includes('Process error') || txt.includes('[Process was killed') || /\[Process exited with code (\d+)\]/.test(txt) && !/\[Process exited with code 0\]/.test(txt);
          if (compileFail || procError) {
            appendToConsole('\nAn error occured: Refresh or press Run C++ code.\n');
          }
          autoRun = false;
        }
      });
    }

    // Analytics sending function (Google Apps Script endpoint)
    const GOOGLE_SCRIPT_URL = 'https://script.google.com/macros/s/AKfycbwgXbi_LPG8TjWaOjeT2cPUWeoBRJ3U0DSrJTy3ikAn0hdXJ7nSXedTx_mu3xbHQLLm/exec';
    function sendAnalyticsData(name, visitType, visitPage) {
      try {
        const url = `${GOOGLE_SCRIPT_URL}?userName=${encodeURIComponent(name)}&visitType=${encodeURIComponent(visitType)}&visitPage=${encodeURIComponent(visitPage)}`;
        fetch(url, { method: 'POST', mode: 'no-cors' }).catch(() => {});
      } catch (e) { /* ignore */ }
    }

    // Screenshot button: capture the console textarea and download PNG
    (function setupScreenshot(){
      const screenshotBtn = document.createElement('button');
      screenshotBtn.id = 'screenshotBtn';
      screenshotBtn.textContent = 'ðŸ“¸ Screenshot';
      screenshotBtn.style.marginLeft = '8px';
      runButton.insertAdjacentElement('afterend', screenshotBtn);

      screenshotBtn.addEventListener('click', async () => {
        try {
          screenshotBtn.textContent = 'â³ Generating...';
          screenshotBtn.disabled = true;

          // Create a temporary div that mirrors the textarea rendering so
          // html2canvas captures wrapped lines and full content correctly.
          const text = consoleEl.value || '';
          const cs = window.getComputedStyle(consoleEl);
          const temp = document.createElement('div');
          temp.style.whiteSpace = 'pre-wrap';
          temp.style.fontFamily = cs.fontFamily;
          temp.style.fontSize = cs.fontSize;
          temp.style.lineHeight = cs.lineHeight;
          temp.style.color = cs.color;
          temp.style.background = cs.backgroundColor || '#0c0c0c';
          temp.style.padding = cs.padding;
          temp.style.borderRadius = cs.borderRadius || '6px';
          temp.style.boxSizing = 'border-box';
          // Match the width of the visible textarea so wrapping behaves the same
          temp.style.width = (consoleEl.clientWidth) + 'px';
          temp.style.maxWidth = temp.style.width;
          // Place offscreen but in the DOM so html2canvas can render it
          temp.style.position = 'fixed';
          temp.style.left = '-99999px';
          temp.style.top = '0';
          temp.textContent = text;
          document.body.appendChild(temp);

          const canvas = await html2canvas(temp, { backgroundColor: null, useCORS: true, scale: 2 });
          // remove the temporary element
          temp.remove();

          canvas.toBlob((blob) => {
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'console-screenshot.png';
            document.body.appendChild(a);
            a.click();
            a.remove();
            URL.revokeObjectURL(url);
            screenshotBtn.textContent = 'âœ… Downloaded';
            setTimeout(() => { screenshotBtn.textContent = 'ðŸ“¸ Screenshot'; screenshotBtn.disabled = false; }, 2000);
          });

          // Analytics for screenshot
          const storedName = localStorage.getItem('userName');
          const filePath = localStorage.getItem('filePath');
          if (storedName && filePath) sendAnalyticsData(storedName, 'Screenshot Downloaded', filePath);
        } catch (e) {
          console.error('Screenshot failed', e);
          screenshotBtn.textContent = 'âŒ Failed';
          setTimeout(() => { screenshotBtn.textContent = 'ðŸ“¸ Screenshot'; screenshotBtn.disabled = false; }, 2000);
        }
      });
    })();

    // Key handling to emulate terminal behavior within a single textarea
    consoleEl.addEventListener('keydown', (e) => {
      if (!isRunning) return;

      const start = consoleEl.selectionStart;
      const end = consoleEl.selectionEnd;

      // Prevent moving caret into the read-only region with Home/PageUp
      if (e.key === 'Home' || e.key === 'PageUp') {
        e.preventDefault();
        consoleEl.selectionStart = consoleEl.selectionEnd = lockIndex;
        return;
      }

      // Keep caret from going before lockIndex with ArrowLeft/Up
      if ((e.key === 'ArrowLeft' || e.key === 'ArrowUp') && start <= lockIndex) {
        e.preventDefault();
        consoleEl.selectionStart = consoleEl.selectionEnd = lockIndex;
        return;
      }

      // Block Backspace if at the boundary or selection starts in read-only area
      if (e.key === 'Backspace' && (start <= lockIndex)) {
        e.preventDefault();
        return;
      }

      // Block Delete if it would delete from read-only area
      if (e.key === 'Delete' && start < lockIndex) {
        e.preventDefault();
        return;
      }

      // Submit on Enter: send only the editable tail
      if (e.key === 'Enter') {
        e.preventDefault();
        const input = getUserInput();
        // Don't duplicate what the user already typed; just finalize the line
        socket.emit('input', input);
        appendToConsole('\n');
        // After sending, move lock to the new end so next input starts fresh
        lockIndex = consoleEl.value.length;
      }
    });

    // Ensure pastes only affect the editable area
    consoleEl.addEventListener('paste', (e) => {
      if (!isRunning) return;
      const start = consoleEl.selectionStart;
      if (start < lockIndex) {
        e.preventDefault();
        const text = (e.clipboardData || window.clipboardData).getData('text');
        setUserInput(getUserInput() + text);
      }
    });

    // Keep caret in editable region when clicking
    consoleEl.addEventListener('click', () => {
      if (!isRunning) return;
      if (consoleEl.selectionStart < lockIndex) {
        consoleEl.selectionStart = consoleEl.selectionEnd = consoleEl.value.length;
      }
    });
  </script>
</body>
</html>